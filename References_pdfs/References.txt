References

######################################################################################################################################
[1] (PAPER) Takuya Akiba, Yoichi Iwata, and Yuichi Yoshida. Dynamic and historical shortest-path distance queries on large evolving 
networks by pruned landmark labeling. In 23rd International World Wide Web Conference, WWW ’14, Seoul, Republic of Korea, 
April 7-11, 2014, pages 237–248, 2014.
--------------------------------------------------------------------------------------------------------------------------------------
url: https://dl.acm.org/doi/pdf/10.1145/2566486.2568007
Insights: 
1) They propose a dynamic indexing scheme for queries on the last snapshot.
2) They designed another dynamic indexing scheme that can also answer two kinds of historical queries with regard to not only 
the latest snapshot but also previous snapshots.
3) The methods can construct indices from large graphs with millions of vertices, answer queries in microseconds, and update 
indices in milliseconds.
4) Experiments on real and synthetic evolving networks.

Type of queries: 1. shortest path between two vertices, 2. distance between two vertices (indicates the closeness of the two users)

They assume the following two scenarios: 1. ask only contemporary queries: last snapshot 2. ask historical queries: previous snapshots

Assumptions: undirected unweighted graphs and consider only distance queries but supporting directed and/or weighted graphs 
and shortest-path queries is discussed. Also, when we assume a dynamic graph, we ignore removals (widely used). The newly 
inserted vertex is isolated. They choose vertices by the decreasing order of degrees.

Problem definition: 
	Problem 1 (Contemporary Distance Query):
	Given: Two query vertices s, t.
	Answer: Distance d τ (s, t), where τ is the last time when a vertex or an edge is added.

	Problem 2 (Historical Snapshot Distance Query):
	Given: Two query vertices s, t and time τ .
	Answer: Distance d τ (s, t).

	Problem 3 (Historical Distance Change-point Query):
	Given: Two query vertices s, t.
	Answer: Set C(s, t) = {(τ 1 , δ 1 ), (τ 2 , δ 2 ), . . .} where (τ i , δ i ) ∈ C(s, t) if and only if δ i = d τ i (s, t) 6 = d τ i −1 (s, t).

Contemporary Distance Query: The idea behind an efficient update algorithm is to carefully resume and stop pruned BFSs. They 
only add new label entries or rewrite distances of existing label entries. (Lemma 4.2) -> If the distance from vertex v k to 
vertex u has changed, then all the new shortest paths between them pass through the new edge (a, b). 
Update Algorithm for Pruned Labeling: PrefixalQuery(s, t, M, k) = min {δ s + δ t | (v i , δ s ) ∈ M (s), (v i , δ t ) ∈ M (t), i ≤ k} 
the answer to the query between vertices s and t computed from the index M only using distances to vertices whose IDs are at most k.

Historical Distance Query: They start from an algorithm based on dynamic programming, next they turn the algorithm into a 
BFS-like algorithm, and then introduce pruning to the algorithm. 

To efficiently answer not only distance but also the shortest path, they store parents of label entries in BFS trees, and 
ascend the trees from the two end points to restore the path.
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[2] (SURVEY) Renzo Angles, Marcelo Arenas, Pablo Barceló, Aidan Hogan, Juan L. Reutter, and Domagoj Vrgoc. Foundations of modern query 
languages for graph databases. ACM Comput. Surv., 50(5):68:1–68:40, 2017.
--------------------------------------------------------------------------------------------------------------------------------------
url: https://dl.acm.org/doi/pdf/10.1145/3104031
Insights: 
1) Firstly, they discuss two graph data models (Section 2): edge-labelled graphs, where nodes and edges in labelled graphs can be annotated 
with additional meta-information. 
2) (Section 3), they discuss graph patterns, where a graph-structured query is matched against the graph database. 
3) (Section 4) introduces navigational expressions, can match paths of arbitrary length. 

GRAPH DATA MODELS -->  
+ Edge-labelled graphs: A simple and widely adopted solution is the use of edge-labelled graphs, where we additionally assign labels
 to edges that indicate the different types of relationships in the domain being described. An edge-labelled graph does not 
 impose any particular restriction on the topology of graphs. Can encode complex information.
+ Property Graphs: Both edges and nodes can be labelled. 

GRAPH PATTERNS -->
+ Query languages: SPARQL, Cypher, Gremlin
+ Basic Graph Patterns: a bgp for querying an edge-labelled graph is just an edge-labelled graph where variables can now appear 
as nodes or edge labels.
+ Complex Graph Patterns: (bgps) cover the natural join, and selection based on equality. Cgp cover projection, union, difference,
 optional, and filter (which covers selection). 
+ Path queries: x -> (knows) y. The output can be Boolean, Nodes, Paths, Graphs.

######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[4] (PAPER) Michele Berlingerio, Francesco Bonchi, Björn Bringmann, and Aristides Gionis. Mining graph evolution rules. In Machine Learning 
and Knowledge Discovery in Databases, European Conference, ECML PKDD 2009, Bled, Slovenia, September 7-11, 2009, Proceedings, 
Part I, pages 115–130, 2009.
--------------------------------------------------------------------------------------------------------------------------------------
url: https://link.springer.com/content/pdf/10.1007/978-3-642-04180-8_25.pdf
Insights: 
1) Given a sequence of snapshots of an evolving graph, they aim at discovering rules describing the local changes occurring in it.
2) Extract patterns (structural changes in dynamic graphs) whose frequency is larger than a minimum support threshold.

Patterns of Graph Evolution -->
+ Time-Evolving Graphs: To each edge e = (u, v) a time-stamp t(e) = arg min j {E j | e ∈ E j } is assigned (first appearance).
+ Patterns: a pattern P of G is a (connected)subgraph of G that in addition to matching edges of G also matches their timestamps, 
and if present, the properties on the nodes and edges of G.
	+ Absolute-time pattern: we are not interested in patterns where all edges have the same timestamp.
	+ Relative-time Pattern: They obtain naturally forming equivalence classes of structurally isomorphic relative time patterns 
	that differ only by a constant on their edge time-stamps.
+ Support metric: support of the pattern P in the host-graph G. Property: G, P and P', where P is a subgraph of P', it must hold 
that σ(P, G) ≥ σ(P', G). It is closer to the real number of occurrences in the graph. How often an event may happen compared to 
other specific changes.
+ Rules and Confidence Measure: how likely is a certain sequence of steps? Confidence for each transition. Each step can be 
considered as a rule body→head with both body and head being patterns. 

Questions -->
+ Q1. Do the extracted patterns and rules characterize the studied network? Yes, using the confidence of rules. No, using the support.
+ Q2. Do different time granularities influence the confidence of the rules? Rules that have higher weekly confidence than monthly.
+ Q3. How do the different confidence definitions compare? support-based confidence is a more appropriate measure to use.
+ Q4. How do the parameters and the type of dataset influence the number of derivable rules, the number of patterns obtained, 
and the running time? rules extracted from a dataset with weekly granularity have higher confidence than rules extracted from a 
dataset with yearly granularity. the number of extracted patterns grows as a function of the number of edges allowed in the pattern. 
The running times are very different, the number of extracted patterns is almost the same. More edge labels allow for more patterns 
to be found. Less edge labels allow patterns to be found more repeatedly. 

######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[6] (PAPER) Petko Bogdanov, Misael Mongiovì, and Ambuj K. Singh. Mining heavy subgraphs in time-evolving networks. In 11th IEEE  International 
Conference on Data Mining, ICDM 2011, Vancouver, BC, Canada, December 11-14, 2011, pages 81–90, 2011.
--------------------------------------------------------------------------------------------------------------------------------------
url: https://ieeexplore.ieee.org/document/6137212/
Insights: 
1) High-scoring subgraph discovery in time-evolving networks (Heaviest Dynamic Subgraph (HDS)). NP-hard.
2) A naı̈ve approach would enumerate all O(t^2) sub-intervals, our solution performs an effective pruning of the sub-interval space by 
considering O(tlog(t)) groups of sub-intervals and computing an aggregate of each group in logarithmic time.

High scoring sub-networks correspond to congested locations over an extent in time.
Assumptions:
+ edge-weighted {-1, +1} network whose weights evolve in time (edge-evolving network for short)
+ score of a temporal subgraph is defined as the sum of the edge weights.
+ Find top-k high-scoring non-overlapping subgraphs.

Admitting solutions that contain negative edges has several advantages. 

Proposes:
+ pruning sub-intervals named MEDEN (Mining EDge-Evolving Networks). Only highly overlapping sub-intervals are grouped together.
+ A heuristic for Heaviest Subgraph (HS) -> TopDown
+ Upper bounds for HS -> The pruning procedure bounds the solution in each sub-interval and discards the sub-intervals whose upper bound 
is smaller than a previously found solution. Summing all the positive edges.
+ A filter-and-verify algorithm for HDS -> for all Not pruned sub-intervals [l, r] do T opDown( Ḡ(l, r)). We reduce the complexity of the 
initial filtering phase to O(t·log 2 (t)·|E|) by grouping intervals, as described in the next section.
+ SCALABLE FILTERING BY SUB - INTERVAL GROUPING -> The grouping of sub-intervals follows an intuitive principle: sub-intervals with 
significant overlap produce similar aggregated graphs and hence solutions of similar score. The fraction of overlap between two sub-intervals 
as the ratio of the lengths of their intersection and union. Minimum overlap: (k_1 − i + 1)/(k_2 − i + 1), where S(i, k_1, k_2). 
+ MEDEN (final algorithm) -> It augments Basic with the scalable group-based filtering phase. After building an interval index on G (Step
1), we group the intervals, compute the dominating graphs and compute U B SOP for each group in the partitioning S G,α (Steps 2-5). 
We estimate a lower bound (Step 6) by interpolating U B SOP for intervals for which it is not computed due to the grouping. Next, 
we prune whole groups by progressively applying our upper bounds on the group dominating graphs (Steps 7-9). The intervals from all groups
that cannot be pruned are then processed as in Basic, while using the index to obtain their aggregated graphs. The best temporal subgraph 
is returned as a result.

Experiments:
+ real-world networks: (i) the highway transportation network of Los Angeles, California, (ii) the Enron email dataset 2 and 
(iii) a subset of the Twitter follower graph and the corresponding tweeting activity.

MEDEN uses tight upper bounds of the optimal solution to prune irrelevant time intervals. The method is not sensitive to its single parameter α. 
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[7] (SURVEY) HongYun Cai, Vincent W. Zheng, and Kevin Chen-Chuan Chang. A comprehensive survey of graph embedding: Problems, techniques, and applications.  IEEE Trans. Knowl. Data Eng., 30(9):1616–1637, 2018.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://ieeexplore.ieee.org/document/8294302
Insights: 
Different types of embedding input carry different information to be preserved in the embedded space and thus pose different challenges
to the problem of graph embedding.

2 PROBLEM FORMALIZATION:
Types of embeddings: 
+ Node embedding -> preserves the similarity to its neighbouring nodes in the embedded space
+ Edge embedding
+ Hybrid embedding
+ Whole-graph embedding -> represents a whole graph as a vector so that the graph-level similarity is preserved

Categorizing graph embedding based on 1) the problem settings and 2) the embedding techniques
Input graphs: 
+ Homogeneous Graph -> All nodes in G belong to a single type and all edges belong to one single type
+ Heterogeneous Graph -> All nodes in G belong to more than one type and all edges belong to more than one single type
+ Graph with Auxiliary Information -> (knowledge graph) a directed graph whose nodes are entities and edges are subject-property-object triple facts
+ Graph Constructed from Non-relational Data
Output: See above types of embeddings

Each graph is represented as either a d-dimensional vector (for a whole graph) or a set of d-dimensional vectors with each vector representing 
the embedding of part of the graph (e.g., node, edge, substructure).

3 PROBLEM SETTINGS OF GRAPH EMBEDDING:
+ 3.1.1 Homogeneous Graph -> Weighted and directed graphs present their properties best into the embedding space, in contrast with the unweighted and 
							undirected graphs.
							Nodes connected by higher-weighted edges are embedded closer to each other.
+ 3.1.2 Heterogeneous Graph -> Community-based Question Answering (cQA) sites, Multimedia Networks, Knowledge Graphs
+ 3.1.3 Graph with Auxiliary Information -> Label (Nodes with different labels should be embedded far away from each other), 
											Attribute (In contrast to a label, an attribute value can be discrete or continuous),
											Node feature (Most node features are text, which are provided either as a feature vector for each node or as a document,
											Information propagation (e.g. retweet)
+ 3.1.4 Graph Constructed from Non-relational Data -> the input is a feature matrix X ∈ R^(|V| × N) where each row X i is an N-dimensional 
feature vector for the i -th training instance.

3.2 Graph Embedding Output:
+ 3.2.1 Node Embedding -> 
+ 3.2.2 Edge Embedding -> 
+ 3.2.3 Hybrid Embedding -> Hybrid embedding is the embedding of a combination of different types of graph components, e.g, node + edge (i.e., substructure), node + community.
+ 3.2.4 Whole-Graph Embedding -> a graph is represented as one vector and two similar graphs are embedded to be closer (proteins). 

4 GRAPH EMBEDDING TECHNIQUES:

4.1 Matrix Factorization:
+ 4.1.1 Graph Laplacian Eigenmaps -> The optimal a ’s are eigenvectors with the maximum eigenvalues in solving XW(X^T) a = λXD(X^T) a. Euclidean distance between two feature vectors X i and X j as W ij . 
+ 4.1.2 Node Proximity Matrix Factorization -> directly factorize node proximity matrix. 
Summary: Matrix Factorization (MF) is mostly used to embed a graph constructed from non-relational data for node embedding, which is the typical setting of graph Laplacian eigenmap problems. MF is also used to embed homogeneous graphs.

4.2 Deep Learning:
+ 4.2.1 DL based Graph Embedding with Random Walk ->  The second-order proximity in a graph can be preserved in the embedded space by maximizing the probability of observing the neighbourhood of a node conditioned on its embedding. A graph is represented as a set of random walk paths sampled from it. 
+ 4.2.2 DL based Graph Embedding without Random Walk -> The multi-layered learning architecture is a robust and effective solution to encode the graph into a low dimensional space. Autoencoder, Deep Neural Network, 

4.3 Edge Reconstruction based Optimization: optimizes an edge reconstruction based objective function
+ 4.3.1 Maximizing Edge Reconstruction Probability -> Good node embedding maximizes the probability of generating the observed edges in a graph.
+ 4.3.2 Minimizing Distance-based Loss -> The node proximity calculated based on node embedding should be as close to the node proximity calculated based on the observed edges as possible.
+ .3.3 Minimizing Margin-based Ranking Loss -> A node’s embedding is more similar to the embedding of relevant nodes than that of any other irrelevant node.
Summary: Edge reconstruction based optimization is applicable for most graph embedding settings. As far as can be observed, only graph constructed from non-relational data and whole-graph embedding have not been tried. The reason is that reconstructing manually constructed edges is not as intuitive as in other graphs. Moreover, as this technique focuses on the directly observed local edges, it is not suitable for whole-graph embedding

4.4 Graph Kernel:
The whole graph structure can be represented as a vector containing the counts of elementary substructures that are decomposed from it.
+ Graphlet, Subtree Patterns, Random Walks
Summary: A graph kernel is designed for whole-graph embedding only as it captures the global property of a whole graph. The type of input graph is usually a homogeneous graph or a graph with auxiliary information.

4.5 Generative Model:
A generative model can be defined by specifying the joint distribution of the input features and the class labels, conditioned on a set of parameters.
+ 4.5.1 Embed Graph Into The Latent Semantic Space -> Nodes are embedded into a latent semantic space where the distances among nodes explain the observed graph structure.
+ 4.5.2 Incorporate Latent Semantics for Graph Embedding -> Nodes which are close in the graph and having similar semantics should be embedded closer. The node semantics can be detected from node descriptions via a generative model.
Summary: Generative model can be used for both node embedding and edge embedding. As it considers node semantics, the input graph is usually a heterogeneous graph or a graph with auxiliary information.

4.6 Hybrid Techniques and Others:
Sometimes multiple techniques are combined in one study.

5 APPLICATIONS:

5.1 Node Related Applications:
+ 5.1.1 Node Classification -> Node classification is conducted by applying a classifier on the set of labelled node embedding for training. Then given the embedding of an unlabelled node, the trained classifier can predict its class label.
+ 5.1.2 Node Clustering -> After representing nodes as vectors, the traditional clustering algorithms can then be applied on the node embedding.
+ 5.1.3 Node Recommendation/Retrieval/Ranking -> 

5.2 Edge Related Applications:
+ 5.2.1 Link Prediction + 5.2.2 Triple Classification -> for knowledge graphs

5.3 Edge Related Applications:
+ 5.3.1 Graph Classification + 5.3.2 Visualization 

######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[8] (PAPER) Ciro Cattuto, Marco Quaggiotto, André Panisson, and Alex Averbuch. Time-varying social networks in a graph database: a neo4j use case. 
In First International Workshop on Graph Data Management Experiences and Systems, GRADES 2013, co-loated with SIGMOD/PODS 2013, 
New York, NY, USA, June 24, 2013, page 11, 2013.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://dl.acm.org/doi/pdf/10.1145/2484425.2484442
Insights: 
1) It is important to design solutions that allow rich queries that simultaneously involve the topology of the social network, temporal 
information on the presence and interactions of individual nodes, and node metadata.
2) Here we introduce a data model for time-varying social network data that can be represented as a property graph in the Neo4j graph database. 
3) We use time-varying social network data collected by using wearable sensors and study the performance of real-world queries, pointing 
to strengths, weaknesses and challenges of the proposed approach.

Data (couple of people and sensors)
For each pair of participants, the detailed sequence of their contacts, with beginning and ending times. 
These data can be represented as time-varying proximity networks, obtained by temporally aggregating the raw data stream from the proximity 
sensors over temporal frames of a given duration, here chosen as ∆t = 20s. For each consecutive time interval (frame) of duration ∆t we build 
a proximity graph where nodes represent individuals, and edges represent proximity relations between individuals that were recorded during the corresponding frame. Within a frame, an interaction is considered active from the beginning of the frame to the end of the frame. In this 
representation, interactions and actors appear or disappear at frame boundaries only.

3. TECHNICAL CHALLENGES
3.1 Modeling Time-Varying Networks -> adjacency matrices or adjacency lists allow to build specialized data processing pipelines, they have numerous limitations.
3.2 Storage & Retrieval of Large Networks -> The topology of real-world graphs is heterogeneous. There are two main sources of heterogeneity: the first is the topological heterogeneity of the social networks we measure, the second is the temporal heterogeneity.

4. DATA MODEL
4.1 Time-Varying Social Network
Edges as undirected and weighted (it generalizes to directed weighted edges and to multi-relational networks). We have to define the graph schema.

4.2 Temporal indexing
+ They build a tree that explicitly represents the temporal hierarchy of the dataset. 
+ Each level is a timestamp such as year, month, week, day, hours 
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[9] (PAPER) Gabriel Campero Durand, Marcus Pinnecke, David Broneske, and Gunter Saake. Backlogs and interval timestamps: Building blocks for supporting 
temporal queries in graph databases. In Proceedings of the Workshops of the EDBT/ICDT 2017 Joint Conference (EDBT/ICDT 2017), Venice, Italy, 
March 21-24, 2017., 2017.
--------------------------------------------------------------------------------------------------------------------------------------

url: 
Insights:
1) To include backlogs in the model we examine two alternatives: (1) global indexes, and (2) using the graph as an index by resorting to 
timestamp denormalization.

2. FUNDAMENTALS
Description of two major temporal data representation models that have been used for this purpose, interval timestamps and backlogs.
2.2 Interval timestamps:
+ For instance, consider two temporal objects A and B with timestamps t(A) = [d start , d end ) and t(B) = [d 0 start , d 0 end ). 
The object A exists before the object B if (d start < d 0 start ) holds. Both objects A and B exist together in a certain time span 
if also (d end > d 0 start ) holds.

2.3 Backlogs:
+ It is a list of events ordered by time.

3. TIME IN PROPERTY GRAPHS
how both time representations could be used for the commonplace task of density calculation. This task requires to count the number of 
vertices and edges valid at a given timepoint.
1. Global Indexing. In this alternative, global indexes covering creation and deletion times of items can be used at run-time to efficiently 
reconstruct ordered sets of backlogs for given periods (Figure 3, with only the timestamped nodes and edges).
2. Graph as an index. Another alternative is to use the graph as an index in itself (GRAIN), by using a special class of edges –backlog edges,
 connected to logger meta-vertexes (Figure 3, considering all entities). The collection of backlog edges (going out from the 
 logger vertexes) serves as a backlog table (Figure 2).
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[10] (PAPER) Wenfei Fan, Jianzhong Li, Shuai Ma, Nan Tang, Yinghui Wu, and Yunpeng Wu. Graph pattern matching: From intractable to polynomial 
time. PVLDB, 3(1):264–275, 2010.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://dl.acm.org/doi/pdf/10.14778/1920841.1920878?download=true
Insights:
1) an edge denotes the connectivity in a data graph within a predefined number of hops
2) graph pattern matching can be performed in cubic-time
3) develop algorithms for incrementally finding matches when data graphs are updated
4) the revised notion of graph pattern matching allows us to identify communities commonly found in real-world networks

GOAL: find all subgraphs of G that are isomorphic to P (pattern)

2. Graph Pattern Matching Revised:
+ 2.1 Data Graphs and Pattern Graphs -> A pattern graph is defined as P = (V p , E p , f v , f e ), where (1) V p and E p are the set 
of nodes and the set of directed edges, respectively, as defined for data graphs; (2) f v is a function defined on V p such that 
for each node u, f v (u) is the predicate of u, defined as a conjunction of atomic formulas of the form A op a; here A denotes an attribute, 
a is a constant, and op is a comparison operator <, ≤, =, 6 = , >, ≥; (3) f e is a function defined on E p such that for each edge.
+ 2.2 Bounded Graph Simulation -> Consider a data graph G = (V, E, f A ) and a pattern P = (V p , E p , f v , f e ). ... 
+ For any graph G  and pattern P , if P E G, then there is a unique maximum match in G for P.

3. An Algorithm for Graph Pattern Matching
They present the algorithm. dag(Directed acyclic graph) patterns

Summary: Our algorithms are efficient and scale well with the size of data graphs, and with the size of pattern graphs. Our incremental 
algorithm efficiently processes batch updates δ when δ is reasonably large.
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[11] (PAPER) Nathalie T. H. Gayraud, Evaggelia Pitoura, and Panayiotis Tsaparas. Diffusion maximization in evolving social networks. In Proceedings 
of the 2015 ACM on Conference on Online Social Networks, COSN 2015, Palo Alto, California, USA, November 2-3, 2015, pages 125–135, 2015.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://dl.acm.org/doi/pdf/10.1145/2817946.2817965
Insights: 
1) we study diffusion on such evolving networks and extend the popular Independent Cascade and Linear Threshold models to account for 
network evolution.
2) Introduction of two natural variations, a persistent and a transient one, to capture diffusions of different types.

3. PRELIMINARIES:
+ Evolving graphs -> We model an evolving graph as a sequence of n graphs G = {G 1 , G 2 , ..., G n }, defined over the same set of nodes V 
, where the set of edges differs between time-stamps. (The union graph (which can also be defined as a multi-graph, or a weighted graph) is the aggregation of the sequence into a single graph. This is a common way to transform an evolving graph into a static one.)
+ Diffusion and network evolution -> nodes are in two states: either active or inactive. Diffusion starts with a set of active nodes A 0 and then proceeds in discrete steps.
+ time = two distinct time-tracks that run in parallel: the graph evolution time, where a time-step is defined by a graph instance in 
the graph sequence, and the diffusion time, where a time-step is defined by one step in the diffusion process.

* the possibility that the diffusion time runs faster than the evolution time.

(1) Transient diffusion processes, where the effect of a node activation is “local” in time. This models the case where the diffusion 
capability is short-lived and localized in time; 
(2) Persistent diffusion processes, where the activation of a node has an effect that lasts beyond a single time instance. This models 
the case where the diffusion capability can persist over time. 

4. PROBLEM DEFINITION:
+ diffusion maximization problem = there is an item that we want to spread in the network. Our goal is to select a small set of influential 
nodes in the network that will initiate the diffusion, such that the spread of the item is maximized.

+ Problem 1 "Spread Maximization on Evolving Graphs problem" -> Given a sequence of graphs G = {G 1 , G 2 , ..., G n } and an integer k, 
for a given  diffusion model D, find a set I = {v 1 t 1 , ..., v k k }, v i 6 = v j , of k node instances to be activated, such that 
σ D (I) is maximized.

5. EVOLVING MODELS:
+ 5.1 Evolving IC Model
++ 5.1.1 Transient EIC Model -> a node u can activate its neighbors only immediately after the time instance that it 
becomes active. When a node becomes infected it has a probability of infecting its neighbors, and then it becomes inoculated.
++ 5.1.2 Persistent EIC Model -> the item to be diffused, and the interest of the nodes in the item are persistent. A node u that becomes
 active at time t is given a chance to activate another node v at the first time instance after t that u and v become connected.
+ 5.2 Evolving LT Model: each node has a threshold θ v chosen uniformly at random in the interval [0, 1]. If (u, v) is an incoming 
edge to v, and u is active, we say that (u, v) is live. Node v is activated when the sum of weights over the live edges exceeds the 
threshold θ v .
++ 5.2.1 Transient ELT Model -> In this model, the diffusion process is similar to that in the static graph, but the total incoming weight
 of live edges is computed only over the live edges that are all present in a single graph instance.
++ 5.2.2 Persistent ELT Model -> assume that influence persists over time. A node accumulates the influence of the active nodes it has 
met in the past. When the accumulated influence crosses the node’s threshold it becomes activated.

We address two fundamental issues: 
- (1) How does the timing of the activation of the influencers affect the diffusion spread? -> clearly demonstrate the importance of the
 activation time of a node.
- (2) Does the evolution of the network affect the estimation of the spread? -> For any practical application that wants to make decisions 
based on the size of spread, using the static graph will yield a very poor estimate of the true diffusion on the evolving graph. when 
using the initiator set obtained for the static graph on the evolving graph, performance is poor
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[12] (PAPER) William L. Hamilton, Payal Bajaj, Marinka Zitnik, Dan Jurafsky, and Jure Leskovec. Embedding logical queries on knowledge graphs. 
In Advances in Neural Information Processing Systems 31: Annual Conference on Neural Information Processing Systems 2018, NeurIPS 2018, 
3-8 December 2018, Montréal, Canada., pages 2030–2041, 2018.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://papers.nips.cc/paper/7473-embedding-logical-queries-on-knowledge-graphs.pdf
Insights: 
1) low-dimensional embeddings of knowledge graphs is a powerful approach used to predict unobserved or missing edges between entities.
2) They introduce a framework to efficiently make predictions about conjunctive logical queries
3) In our approach, they embed graph nodes in a low-dimensional space and represent logical operators as learned geometric operations 
(e.g., translation, rotation) in this embedding space. By performing logical operations within a low-dimensional embedding space, 
their approach achieves a time complexity that is linear in the number of query variables.
4) They develop graph query embeddings (GQEs), an embedding-based framework that can efficiently make predictions about conjunctive queries 
on incomplete knowledge graphs. The key idea behind GQEs is that we embed graph nodes in a low-dimensional space and represent logical 
operators as learned geometric operations (e.g., translation, rotation) in this embedding space. After training, we can use the model 
to predict which nodes are likely to satisfy any valid conjunctive query, even if the query involves unobserved edges.

* Reddit network (e.g., “recommend posts that user A is likely to downvote, but user B is likely to upvote”)

4 Proposed Approach
- we learn how to embed any conjunctive graph query into a low-dimensional space. They represent logical query operations as geometric 
operators that are jointly optimized on a low-dimensional embedding space along with a set of node embeddings.
- the embedding q for any query q can be generated and used to predict the likelihood that a node v satisfies the query q.
- In particular, we want to generate query embeddings q and node embeddings z v , so that the likelihood or “score” that v ∈ JqK 
is given by the distance between their respective embeddings: score(q, z u) = q * z u / ||q|| * ||z u||
+ 4.2 Node embeddings -> We assume that every node of type γ has an associated binary feature vector x_u ∈ Z^m_γ , and we compute the
node embedding as Z_u = Z_γ * x_u / |x_u|
where Z_γ ∈ R^d×m_γ is a trainable embedding matrix. In our experiments, the x u vectors are one-hot indicator vectors (e.g., each 
node gets its own embedding) except for posts in Reddit, where the features are binary indicators of what words occur in the post.

+ 4.4 Model training -> The geometric projection operator P, intersection operator I, and node embedding parameters can be trained 
using stochastic gradient descent on a max-margin loss. 
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[14] (PAPER) Takanori Hayashi, Takuya Akiba, and Ken-ichi Kawarabayashi. Fully dynamic shortest-path distance query acceleration on massive 
networks. In Proceedings of the 25th ACM International Conference on Information and Knowledge Management, CIKM 2016, Indianapolis, 
IN, USA, October 24-28, 2016, pages 1533–1542, 2016.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://dl.acm.org/doi/pdf/10.1145/2983323.2983731
Insights:
1)  the first algorithm that can process exact distance queries on fully dynamic billion-scale networks besides trivial non-indexing 
algorithms, which combines an online bidirectional breadth-first search (BFS) and an offline indexing method for handling 
billion-scale networks in memory.
2) bit-parallel shortest-path trees to maintain sets of shortest paths
3) on large-scale social networks with over 1B edges, the proposed method enables us to answer distance queries in around 1 ms, on average

+ Optimized Bidirectional BFS: We present new search expansion heuristics that consider the extremely small average distance of 
vertices in complex networks. When we find a shortest path while conducting our bidirectional BFS, we can immediately terminate 
searches without verifying whether the distance of a found path is truly the shortest distance.
+ Acceleration Based on Bit-Parallel Shortest-Path Trees: We construct shortest-path trees (SPTs) rooted at vertices with the 
highest degrees for further speedup of the querying time of the proposed method. We maintain multiple SPTs with bit-parallelized 
form and reduce the space requirement of each SPT by around four times. Moreover, we present an index size reduction technique to 
further reduce the data structure size in order to handle billion-scale networks in memory, which discards the information of the 
bit-parallel SPTs from some of the vertices and quickly recovers this information if we need it for answering distance queries.
+ Fully Dynamic Update Procedure: We also present fully dynamic update procedures of bit-parallel SPTs. For each bit-parallel SPT, 
we simulate a partial bitparallel BFS as with the update procedure for an SPT. These update procedures are carefully designed to 
correctly propagate changes in the bit-parallelized information of SPTs

3. PRELIMINARIES
We also study efficient methods to reflect dynamic updates of a graph, such as edge insertion and edge deletion, into the index for 
distance queries.

4. PROPOSED METHOD
4.1 Optimized Bidirectional BFS
+ 4.1.1 Search Expansion Heuristics -> The drawback of this algorithm is that we have to continue the search, even if we have 
already found a shortest path, in order to verify that it truly is a shortest path.
+ Our idea is to increase d s or d t in each iteration.
+ 4.1.2 Landmark-Based Acceleration -> avoiding scanning of neighbors of vertices having an extremely large number of neighbors.
4.2 Bit-Parallel SPTs
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[15] (SHORT PAPER) Wenyu Huo and Vassilis J. Tsotras. Efficient temporal shortest path queries on evolving social graphs. In Conference on 
Scientific and Statistical Database Management, SSDBM ’14, Aalborg, Denmark, June 30 - July 02, 2014, pages 38:1–38:4, 2014.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://dl.acm.org/doi/pdf/10.1145/2618243.2618282
Insights:
1)  Our shortest-path queries are “temporal”: they can refer to any time-point or time-interval in the graph’s evolution, and 
corresponding valid answers should be returned. 
2)  extend the traditional Dijkstra’s algorithm to compute shortest-path distance(s) for a time-point or a time-interval. 
3)  index techniques such as Contraction Hierarchies (CH)

2. TEMPORALLY EVOLVING GRAPH
- directed or undirected
- If G is a weighted graph, an edge is represented as a triplet <u, v, w(of the edge) >
- Each node is represented in a triplet as <v, ts(v), te(v)> which implies that node v appears in the graph snapshots during the 
time interval [ts(v), te(v)).
- <u, v, w, ts(e), te(e)> 
- Definition 1. A Time Point Shortest Path query TPSP(TEG, tq, vs, vt) returns the distance of a path p(e1,…,ek) as a sequence of 
edges for query time tq, which is the shortest-path from source node vs to target node vt, (both vs and vt are temporally valid at
query time tq), while all edges in p are valid at query time
- Definition 2. A Time Interval Shortest Path “all” query TISPall(TEG, q, vs, vt) returns a set of distances for paths P = {p1,…,pm} 
which contains all the shortest distance paths from source node vs to target node vt during the query time interrval.

3. FUNDAMENTAL SOLUTION

4. SPEED-UP TECHNIQUES 
- Certain absolute ordering of the vertices is established in the graph.

5. TEMPORAL PARTITIONING
- The GS model is optimal for time-point querying, but it has huge storage overhead and is not efficient for time-interval querying. 
- The TEG model is optimal in space (linear) and efficient for time-interval querying (especially large intervals)
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[18] (SURVEY) Martin Junghanns, André Petermann, Martin Neumann, and Erhard Rahm. Management and analysis of big graph data: Current systems 
and open challenges. In Handbook of Big Data Technologies, pages 457–505. 2017.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://www.researchgate.net/profile/Erhard_Rahm/publication/314210031_Management_and_Analysis_of_Big_Graph_Data_Current_Systems_and_Open_Challenges/links/5c308507a6fdccd6b592fbbd/Management-and-Analysis-of-Big-Graph-Data-Current-Systems-and-Open-Challenges.pdf
Insights:
1) We discuss graph database systems, distributed graph processing systems such as Google Pregel and its variations, and graph 
dataflow approaches based on Apache Spark and Flink.

+ The flexible and efficient management and analysis of “big graph data” holds high promise. At the same time it poses a number of 
challenges for suitable implementations in order to meet the following requirements:
- Powerful graph data model ->  provide a set of powerful graph operators to process and analyze graph data, e.g., to find 
specific patterns or to aggregate and summarize graph data.
- Powerful query and analysis capabilities -> 
- High performance and scalability -> requires the utilization of distributed clusters and in-memory graph processing. 
- Persistent graph storage and transaction support -> It is also desirable to provide OLTP (Online Transaction Processing) functionality 
with ACID transactions for modifying graph data
- Ease of use/graph visualization -> 

2 Graph Databases
+ 2.2 Graph Data Models -> 
+ 2.3 Query Language Support -> 
	- adjacency: reachability queries identify if and how two vertices are connected
	- reachability: from a start vertex within a certain number of traversal steps or via vertices and edges meeting given 
	traversal constraints
	- pattern matching: retrieves subgraphs (embeddings) isomorphic to a given pattern graph. It requires no specific start point 
	but can be  applied to the whole graph
	- aggregation queries: derive aggregated, scalar values from graph structures

	(SPARQL, Gremlin, Cypher query languages)

3 Graph Processing
Dedicate distributed graph processing systems (such as Pregel, Giraph++).
+ 3.1 General Architecture -> 
	- hash or range-based partitioning on vertex labels
	- vertex-centric model: a worker node stores for each of its vertices the vertex value, all outgoing edges including 
	their values and vertex identifiers (ids) of all incoming edges
+ 3.2 Think Like a Vertex ->
	- Google Pregel (vertex compute function): each vertex only has a local view of itself and its immediate neighbors.
		3 steps:
		1. Read all incoming messages,
		2. Update the internal vertex state (i.e., its value)
		3. Send information (i.e., messages) to its neighbors
	- Akka, or Quasar -> r information about the edges of the graph
	- Aggregation: Certain graph algorithms need global knowledge in terms of aggregated values such as the number of vertices 
	in the graph or the total sum of all vertex values.
	- Reducing network communication:  reduce the number of messages between different worker nodes.  If a worker node has 
	multiple messages addressing the same vertex, they can potentially be combined into a single message.
	- Gather-Apply-Scatter (GAS) model (Chaos): 
		1. Aggregates messages addressing the same vertex on the sending worker nodes.
		2. The apply function has the incoming messages as input and updates the vertex state.
		3. The scatter function has the vertex state as input and produces the outgoing messages.
	The computation is parallelized across the vertices.
	- Asynchronous execution: worker nodes do not spend time waiting for other workers to finish (such as Ja-be-Ja, Signal/Collect 
	and GraphChi). It is possible that the message with the true minimum is delayed so that there are additional steps finding 
	the minimum between larger values before the true minimum is found.
	- Graph mutation: modify the graph structure during execution. Giraph supports adding and removing vertices and edges, 
	GraphLab only allows addition
+ 3.3 Think Like a Graph -> 
	- On each worker node n we then create a copy of each vertex that is not internal to n, but is directly connected to 
	an internal vertex of n. These vertices are called boundary vertices and represent the cached vertex values of copied vertices.
 
4 Graph Dataflow Systems -> graph analytics on distributed dataflow systems using Apache Flink
	+ 4.1 Apache Flink -> supports the declarative definition and distributed execution of analytical programs on batch and 
	streaming dataflows. The basic abstractions of such programs are datasets and transformations!
	+ 4.2 Apache Flink Gelly ->  The provided data model is a directed, labeled multigraph where vertex and edge labels are 
	generic, i.e., vertices and edges can carry arbitrary user-defined payload ranging from basic data types such as numbers 
	and strings to complex domain objects.

5 Gradoop (framework, Graph data management and analytics with Hadoop)
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[19] (PAPER) Foteini Katsarou, Nikos Ntarmos, and Peter Triantafillou. Performance and scalability of indexed subgraph query processing 
methods. PVLDB, 8(12):1566–1577, 2015.
--------------------------------------------------------------------------------------------------------------------------------------

url: https://eprints.gla.ac.uk/107199/1/107199.pdf
Insights:
1) Graph data management systems. subgraph query processing; i.e., given a query graph, return all graphs that contain the query.
2) we identify a set of key factors-parameters, that influence the performance of related methods: namely, the number of nodes 
per graph, the graph density, the number of distinct labels, the number of graphs in the dataset, and the query graph size.
3) Grapes, CT-Index, GraphGrepSX, gIndex, Tree+∆, and gCode

- the candidate set is usually much smaller in size than the complete dataset
- Algorithm Performance: A set of methods is selected to represent different key design decisions with respect to the type 
of graph features indexed  i.e., paths, trees, cycles, subgraphs) and the method for generating graph features (i.e., based 
on frequency mining or exhaustive enumeration of graph features).
- Algorithm Scalability:  The existing work focuses only on performance issues – i.e., time and space comparison of the 
algorithms – and fails to look at scalability issues – i.e., what is the performance of the algorithm when both the dataset 
and the graphs grow large and/or more complex.
- systematic evaluation of performance and scalability: 

2. BACKGROUND
+ 2.1 Definitions -> 
	- Graphs: undirected graphs with labels on vertices
	- Graph Isomorphism: Two graphs G = (V, E, L) and G0 = (V0, E0, L0). maps each vertex of G to a vertex of G0(the edges and labels).
	- Subgraph Isomorphism: subgraph isomorphism is injective and thus there may exist edges in E0 for which there are no 
	corresponding edges in E(the subgraph).
	- Graph Density: d = (2 × |E|) / (|V | × (|V | − 1)) , d ∈ [0, 1]
	- Average Degree (undirected graphs): avgdeg = (2 × |E|) / |V|

3. COMPETING ALGORITHMS
+ gIndex ->  uses a frequent mining approach, with graphstructured features. Stores a graph ID list per feature (no location information).
+ Tree+∆ -> uses a frequent mining approach, but initially only indexes tree-structured features of up to a predefined size. all 
tree-structured fragments of the query graphs are enumerated and looked up in the index. the algorithm also enumerates simple 
cycles found in query graph. 
+ gCode -> Enumerates all paths of up to a predefined size. Produces vertex signatures, consisting of three components. 
+ CT-Index -> uses path-, tree- and cycle-structured features.  The canonical labels of all such features are then combined 
and hashed, producing a fixed-size bit array fingerprint for each graph in the dataset. any location information. 
+ GraphGrepSX -> enumerates all paths up to a maximum length using depth first search and organizes them in a suffix tree. 
+  Grapes -> indexing paths of up to a maximum length. maintains location information. being one of the fastest algorithms regarding 
query processing times across most of our scenarios

6. LESSONS LEARNED & CONCLUSIONS
-  As the number of features is superlinear to the size of a graph, the increase of the above two factors leads to a detrimental 
increase in the indexing time, with the frequent mining techniques being more severely affected.
- The number of graphs increases the overall complexity only linearly.
- The increase in the number of distinct labels leads to an easier dataset to index and an easier query workload to process, 
as it results in fewer occurrences of any given feature and thus a decrease in the false positive ratio of the various algorithms.
- The size of query graphs affects all methods, even more so when the datasets consist of dense graphs. This effect is more 
pronounced for frequent mining techniques, even for moderately dense or even sparse graphs.

- The number of subgraphs of size n in a graph is significantly larger than the number of trees of size n, and the trees of 
size n is significantly larger than the number of paths of size n.
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[20] (PAPER) David Kempe, Jon M. Kleinberg, and Amit Kumar. Connectivity and inference problems for temporal networks. J. Comput. Syst. 
Sci., 64(4):820–842, 2002.
--------------------------------------------------------------------------------------------------------------------------------------

url: shorturl.at/zAEJR
Insights:
1) The path "time-respecting" if the time labels on its edges are non-decreasing.
2) How do the basic combinatorial and algorithmic properties of graphs change when we impose this additional temporal condition?
3) Consider connectivity problems, in which we seek disjoint time-respecting paths between pairs of nodes. 
4) Inference problems, in which we seek to reconstruct a partially specified time labeling of a network in a manner consistent 
with an observed history of information flow.

+ Communication in Distributed Networks ->  node-to-node transmissions. If the time labels on the edges of P are monotonically 
non-decreasing.
+ Epidemiology -> the spread of a disease (or a computer virus, or a rumor) can be investigated by studying the time-respecting 
paths in a network.
+ Scheduled Transportation Networks -> strictly time-respecting = if the labels on its edges are increasing. 

** Connectivity problems -> Suppose that a node t has learned a piece of information originally possessed by a node s. 
Q: : for some value of k, are there k (internally) node-disjoint time-respecting paths from s to t?

######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[21] Udayan Khurana and Amol Deshpande. Efficient snapshot retrieval over historical graph data. In 29th IEEE International 
Conference on Data Engineering, ICDE 2013, Brisbane, Australia, April 8-12, 2013, pages 997–1008, 2013.
--------------------------------------------------------------------------------------------------------------------------------------

url: 
Insights:
1) 
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[22] Udayan Khurana and Amol Deshpande. Storing and analyzing historical graph data at scale. In Proceedings of the 19th 
International Conference on Extending Database Technology, EDBT 2016, Bordeaux, France, March 15-16, 2016, Bordeaux, France, 
March 15-16, 2016., pages 65–76, 2016.
--------------------------------------------------------------------------------------------------------------------------------------

url: 
Insights:
1) 
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[23] Min-Soo Kim and Jiawei Han. A particle-and-density based evolutionary clustering method
for dynamic networks. PVLDB, 2(1):622–633, 2009.
[24] Georgia Koloniari and Evaggelia Pitoura. Partial view selection for evolving social graphs.
In First International Workshop on Graph Data Management Experiences and Systems,
GRADES 2013, co-loated with SIGMOD/PODS 2013, New York, NY, USA, June 24, 2013,
page 9, 2013.
[25] Georgia Koloniari, Dimitris Souravlias, and Evaggelia Pitoura. On graph deltas for historical
queries. CoRR, abs/1302.5549, 2013. Proceedings of 1st Workshop on Online Social Systems
(WOSS) 2012, in conjunction with VLDB 2012.
[26] Konect. The Koblenz Network Collection, 2018 (accessed January). http://konect.
uni-koblenz.de/.
[27] Andreas Kosmatopoulos, Kostas Tsichlas, Anastasios Gounaris, Spyros Sioutas, and
Evaggelia Pitoura. Hinode: an asymptotically space-optimal storage model for historical
queries on graphs. Distributed and Parallel Databases, 35(3-4):249–285, 2017.
[28] C. Kosyfaki, N. Mamoulis, E. Pitoura, and P. Tsaparas. Flow motifs in interaction networks.
In EDBT, page To appear, 2019.
[29] Alan G. Labouseur, Jeremy Birnbaum, Paul W. Olsen, Sean R. Spillane, Jayadevan Vijayan,
Jeong-Hyon Hwang, and Wook-Shin Han. The g* graph database: efficiently managing large
distributed dynamic graphs. Distributed and Parallel Databases, 33(4):479–514, 2015.
[30] Theodoros Lappas, Kun Liu, and Evimaria Terzi. Finding a team of experts in social networks.
In Proceedings of the 15th ACM SIGKDD International Conference on Knowledge Discovery
and Data Mining, Paris, France, June 28 - July 1, 2009, pages 467–476, 2009.
[31] Theodoros Lappas, Evimaria Terzi, Dimitrios Gunopulos, and Heikki Mannila. Finding effec-
tors in social networks. In Proceedings of the 16th ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining, Washington, DC, USA, July 25-28, 2010, pages
1059–1068, 2010.
[32] Konstantina Lazaridou, Konstantinos Semertzidis, Evaggelia Pitoura, and Panayiotis
Tsaparas. Identifying converging pairs of nodes on a budget. In Proceedings of the 18th In-
ternational Conference on Extending Database Technology, EDBT 2015, Brussels, Belgium,
March 23-27, 2015., pages 313–324, 2015.
[33] Jure Leskovec, Jon M. Kleinberg, and Christos Faloutsos. Graph evolution: Densification
and shrinking diameters. TKDD, 1(1):2, 2007.
[34] David Liben-Nowell and Jon M. Kleinberg. The link-prediction problem for social networks.
JASIST, 58(7):1019–1031, 2007.
[35] Kun Liu and Evimaria Terzi. Towards identity anonymization on graphs. In Proceedings
of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2008,
Vancouver, BC, Canada, June 10-12, 2008, pages 93–106, 2008.
[36] Andreas Loupasakis, Nikos Ntarmos, and Peter Triantafillou. exo: Decentralized au-
tonomous scalable social networking. In CIDR 2011, Fifth Biennial Conference on Inno-
vative Data Systems Research, Asilomar, CA, USA, January 9-12, 2011, Online Proceedings,
pages 85–95, 2011.
[37] Peter Macko, Virendra J. Marathe, Daniel W. Margo, and Margo I. Seltzer. LLAMA: efficient
graph analytics using large multiversioned arrays. In 31st IEEE International Conference on
Data Engineering, ICDE 2015, Seoul, South Korea, April 13-17, 2015, pages 363–374, 2015.
[38] Youshan Miao, Wentao Han, Kaiwei Li, Ming Wu, Fan Yang, Lidong Zhou, Vijayan Prab-
hakaran, Enhong Chen, and Wenguang Chen. Immortalgraph: A system for storage and
analysis of temporal graphs. TOS, 11(3):14:1–14:34, 2015.
[39] R. Milo, S. Shen-Orr, S. Itzkovitz, N. Kashtan, D. Chklovskii, and U. Alon. Network motifs:
Simple building blocks of complex networks. Science, 298(5594):824–827, 2004.
[40] Vera Zaychik Moffitt and Julia Stoyanovich. Temporal graph algebra. In Proceedings of The
16th International Symposium on Database Programming Languages, DBPL 2017, Munich,
Germany, September 1, 2017, pages 10:1–10:12, 2017.
######################################################################################################################################
######################################################################################################################################
######################################################################################################################################
[41] Vera Zaychik Moffitt and Julia Stoyanovich. Towards sequenced semantics for evolving
graphs. In Proceedings of the 20th International Conference on Extending Database Tech-
nology, EDBT 2017, Venice, Italy, March 21-24, 2017., pages 446–449, 2017.
[42] Mohammad Hossein Namaki, Yinghui Wu, Qi Song, Peng Lin, and Tingjian Ge. Discov-
ering graph temporal association rules. In Proceedings of the 2017 ACM on Conference on
Information and Knowledge Management, CIKM 2017, Singapore, November 06 - 10, 2017,
pages 1697–1706, 2017.
[43] Ashwin Paranjape, Austin R. Benson, and Jure Leskovec. Motifs in temporal networks. In
WSDM, pages 601–610, 2017.
[44] Nikos Parotsidis, Evaggelia Pitoura, and Panayiotis Tsaparas. Selecting shortcuts for a
smaller world. In Proceedings of the 2015 SIAM International Conference on Data Min-
ing, Vancouver, BC, Canada, April 30 - May 2, 2015, pages 28–36, 2015.
[45] Nikos Parotsidis, Evaggelia Pitoura, and Panayiotis Tsaparas. Centrality-aware link recom-
mendations. In Proceedings of the Ninth ACM International Conference on Web Search and
Data Mining, San Francisco, CA, USA, February 22-25, 2016, pages 503–512, 2016.
[46] Evaggelia Pitoura. Historical graphs: Models, storage, processing. Springer.
[47] Shuyao Qi, Nikos Mamoulis, Evaggelia Pitoura, and Panayiotis Tsaparas. Recommending
packages to groups. In IEEE 16th International Conference on Data Mining, ICDM 2016,
December 12-15, 2016, Barcelona, Spain, pages 449–458, 2016.
[48] Chenghui Ren, Eric Lo, Ben Kao, Xinjie Zhu, and Reynold Cheng. On querying historical
evolving graph sequences. PVLDB, 4(11):726–737, 2011.
[49] Chenghui Ren, Eric Lo, Ben Kao, Xinjie Zhu, Reynold Cheng, and David W. Cheung. Effi-
cient processing of shortest path queries in evolving graph sequences. Inf. Syst., 70:18–31,
2017.
[50] Polina Rozenshtein and Aristides Gionis. Temporal pagerank. In Machine Learning and
Knowledge Discovery in Databases - European Conference, ECML PKDD 2016, Riva del
Garda, Italy, September 19-23, 2016, Proceedings, Part II, pages 674–689, 2016.
[51] Siddhartha Sahu, Amine Mhedhbi, Semih Salihoglu, Jimmy Lin, and M. Tamer Özsu. The
ubiquity of large graphs and surprising challenges of graph processing. PVLDB, 11(4):420–
431, 2017.
[52] Konstantinos Semertzidis and Evaggelia Pitoura. Durable graph pattern queries on historical
graphs. In 32nd IEEE International Conference on Data Engineering, ICDE 2016, Helsinki,
Finland, May 16-20, 2016, pages 541–552, 2016.
[53] Konstantinos Semertzidis and Evaggelia Pitoura. Time traveling in graphs using a graph
database. In Proceedings of the Workshops of the EDBT/ICDT 2016 Joint Conference,
EDBT/ICDT Workshops 2016, Bordeaux, France, March 15, 2016., 2016.
[54] Konstantinos Semertzidis and Evaggelia Pitoura. Historical traversals in native graph
databases. In Advances in Databases and Information Systems - 21st European Conference,
ADBIS 2017, Nicosia, Cyprus, September 24-27, 2017, Proceedings, pages 167–181, 2017.
[55] Konstantinos Semertzidis and Evaggelia Pitoura. Top-k durable graph pattern queries on
temporal graphs. IEEE Trans. Knowl. Data Eng., 31(1):181–194, 2019.
[56] Konstantinos Semertzidis, Evaggelia Pitoura, and Kostas Lillis. Timereach: Historical reach-
ability queries on evolving graphs. In Proceedings of the 18th International Conference on
Extending Database Technology, EDBT 2015, Brussels, Belgium, March 23-27, 2015., pages
121–132, 2015.
[57] Konstantinos Semertzidis, Evaggelia Pitoura, Evimaria Terzi, and Panayiotis Tsaparas. Best
friends forever (BFF): finding lasting dense subgraphs. Data Mining and Knowledge Dis-
covery, (Journal track of PKDD 2019), 2019.
[58] Dimitris Serbos, Shuyao Qi, Nikos Mamoulis, Evaggelia Pitoura, and Panayiotis Tsaparas.
Fairness in package-to-group recommendations. In Proceedings of the 26th International
Conference on World Wide Web, WWW 2017, Perth, Australia, April 3-7, 2017, pages 371–
379, 2017.
[59] SNAP. Large Network Dataset Collection, 2018 (accessed January). https://snap.
stanford.edu/data/.
[60] Chayant Tantipathananandh, Tanya Y. Berger-Wolf, and David Kempe. A framework for
community identification in dynamic social networks. In Proceedings of the 13th ACM
SIGKDD International Conference on Knowledge Discovery and Data Mining, San Jose,
California, USA, August 12-15, 2007, pages 717–726, 2007.
[61] Manuel Then, Timo Kersten, Stephan Günnemann, Alfons Kemper, and Thomas Neu-
mann. Automatic algorithm transformation for efficient multi-snapshot analytics on temporal
graphs. PVLDB, 10(8):877–888, 2017.
[62] Apache TinkerPop. 2018 (accessed January). http://tinkerpop.apache.org/.
[63] Paraskevas Tsantarliotis, Evaggelia Pitoura, and Panayiotis Tsaparas. Defining and predicting
troll vulnerability in online social media. Social Netw. Analys. Mining, 7(1):26:1–26:15, 2017.
[64] Jing Wang, Nikos Ntarmos, and Peter Triantafillou. Graphcache: A caching system for graph
queries. In Proceedings of the 20th International Conference on Extending Database Tech-
nology, EDBT 2017, Venice, Italy, March 21-24, 2017., pages 13–24, 2017.
[65] Huanhuan Wu, James Cheng, Silu Huang, Yiping Ke, Yi Lu, and Yanyan Xu. Path problems
in temporal graphs. PVLDB, 7(9):721–732, 2014.
[66] Huanhuan Wu, Yuzhen Huang, James Cheng, Jinfeng Li, and Yiping Ke. Reachability and
time-based path queries in temporal graphs. In 32nd IEEE International Conference on Data
Engineering, ICDE 2016, Helsinki, Finland, May 16-20, 2016, pages 145–156, 2016.
[67] Da Yan, Yingyi Bu, Yuanyuan Tian, and Amol Deshpande. Big graph analytics platforms.
Foundations and Trends in Databases, 7(1-2):1–195, 2017.
[68] Peixiang Zhao and Jiawei Han. On graph query optimization in large networks. PVLDB,
3(1):340–351, 2010.
[69] Lei Zou, Lei Chen, M. Tamer Özsu, and Dongyan Zhao. Answering pattern match queries in
large graph databases via graph embedding. VLDB J., 21(1):97–120, 2012.
[70] Andreas Züfle, Matthias Renz, Tobias Emrich, and Maximilian Franzke. Pattern search in
temporal social networks. In EDBT, pages 289–300, 2018.
[71] Yuan Zuo, Guannan Liu, Hao Lin, Jia Guo, Xiaoqian Hu, and Junjie Wu. Embedding temporal
network via neighborhood formation. In Proceedings of the 24th ACM SIGKDD International
Conference on Knowledge Discovery & Data Mining, KDD 2018, London, UK, August 19-23,
2018, pages 2857–2866, 2018.